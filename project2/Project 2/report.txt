Project 2 reportSatvik Anand 404823011Section 1GLinked list implementation:I implemented the project using a circular doubly-linked list. Each node in the list has one pointer to the previous node and one pointer to the next. The first node in the list has its ‘previous pointer’ pointing to a dummy node called the head node. The last node in the list has its ‘next pointer’ pointing to the head node. They are ordered in the order in which they were inserted and erased from the list.Pseudocode:Constructor    Make size 0    Dynamically allocate a new head node    Head’s next points to head    Head’s previous points to headDestructor    Loop through the entire set        Allocate new node equal to next of head         Make new node’s next’s previous point to head        Make head’s next point to the new node’s next        Delete the new node    Delete the head nodeAssignment operator     Return this if the given Set is equal to this    Else create a temp Set and swap it with the given SetCopy constructor     Make size of this equal to size of other     Dynamically allocate a new node    New node’s next points to head    New node’s previous points to head     Loop through the entire set        Dynamically allocate a new node        Make their values equal        Make the new node’s next point to head         Make the new node’s previous point to head’s previous        Make head’s previous’ next point to the new node.         Make head’s previous point to the new nodeInsert    Loop through the entire set        Return false if the given value is already contained in the set    Dynamically allocate a new node.    Make the new node’s value equal to the given parameter value    If the set is empty        Make the new node’s next point to head        Make the new node’s previous point to head        Make head’s next point to the new node        Make head’s previous point to the new node        Increment size by 1    If the set is not empty        Create a temporary node pointing to head’s previous        Make the new node’s next point to head         Make the new node’s previous point to the temporary node        Make the temporary node’s next point to the new node        Make head’s previous point to the new node        Increment size by 1    Return trueErase    Create a temporary node, temp, pointing to head    Loop through the entire set        Make temp point to temp’s next        If temp’s value is equal to the given value            Create a new node equal to temp            Make temp’s previous’ next point to the new node’s next            Make temp’s next’s previous point to the new node’s previous            Delete the new node            Decrement size             Return true    Return falseGet    If pos is greater than 0 and less than the size of the set        Declare 2 nodes        Loop through the entire set            Declare an integer count            Loop through the entire set again                 If the value of the inner loop is equal to the value from the outer loop                    Increment count            If count is equal to pos                Make value equal to the value of the outer loop                Return true     Return falseSwap    Create a new node temp head equal to head    Make head equal to other’s head     Make other’s head equal to temp head    Create an integer temp size equal to size     Make size equal to other’s size    Make other’s size equal to temp sizeUnite    Create a temporary set     Create an ItemType    Loop through the first set        Use the get function to replace the value of the ItemType        Insert this value into the temporary set using the insert function    Create another ItemType    Loop through the second set        Use the get function to replace the value of the ItemType        Insert this value into the temporary set using the insert function    Equate result to tempSubtract    Create two temporary values    Declare a Boolean to check if something is common between the two given sets    Loop through the first set        Make the Boolean set to false        Use get function to replace one of the temporary values        Loop through the entire second set            Use the get function to replace the other temporary value            If the two values are equal                Set the Boolean to true                Break        If the Boolean is false            Use the insert function to insert the value into the third setTest cases:I tested the project with ItemType as unsigned long. The test cases are as follows:    Set s1;    assert(s1.size() == 0); // tests whether size() works    assert(s1.empty()); // tests whether empty works    assert(s1.insert(1)); // tests whether insert works    assert(s1.contains(1)); // tests whether contains works    assert(s1.size() == 1); // tests whether size() still works    assert(!s1.insert(1)); // tests whether insert returns false if the value is already in the set    assert(s1.insert(2));    assert(s1.size() == 2);    assert(s1.erase(1)); // tests whether erase works    assert(s1.size() == 1);    assert(!s1.contains(1)); // tests whether contains works if you've removed a value        // tests for the get function    Set s2;    ItemType value;    s2.insert(4);    s2.insert(5);    assert(s2.get(0, value));    assert(value == 4);    assert(s2.get(1, value));    assert(value == 5);        //tests for the swap function    s1.swap(s2);    ItemType value2;    assert(s2.size() == 1);    assert(s2.contains(2));    assert(s1.size() == 2);    assert(s1.contains(4));    assert(s1.contains(5));    // checking if the two swapped sets are in the correct order    assert(s2.get(0, value2));    assert(value2 == 2);    assert(s1.get(1, value2));    assert(value2 == 5);    assert(s1.get(0, value2));    assert(value2 == 4);        // tests for unite    Set s3;    unite(s1, s2, s3);    assert(s3.size() == 3);    assert(s3.contains(2));    assert(s3.contains(4));    assert(s3.contains(5));    s1.insert(2); // checking if the same members don't get repeated    assert(s3.size() == 3);    assert(s3.contains(2));    assert(s3.contains(4));    assert(s3.contains(5));        // tests for subtract    Set s4;    s2.insert(5);    subtract(s1, s2, s4);    assert(s4.size() == 1);    assert(s4.contains(4));